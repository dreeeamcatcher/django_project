#!/usr/bin/ruby
#
# Copyright (c) 2011-2018 Apple Inc. All Rights Reserved.
#
# IMPORTANT NOTE: This file is licensed only for use on Apple-branded
# computers and is subject to the terms and conditions of the Apple Software
# License Agreement accompanying the package this file is a part of.
# You may not port this file to another platform without Apple's written consent.
#
# 
# webdavsharing_mapper.rb
#
# Username-to-url mapper tool for WebDAV File Sharing
# Runs under shared Apache instance, as root
# Operates as a RewriteMap program:
# - Launched when Apache is launched with RewriteMap configured
# - Creates an Apache config file based on the WebDAV Share points present at launch time
# - Continues running until Apache is stopped or restarted
# - reads a previously authenticated username from stdin
# - checks if per-user Apache instance is loaded; if not:
# - - creates and loads launchd plist for per-user Apache instance
# - writes URL to stdout; URL is the destination of the proxy in the rewrite
# Killer thread unloads and deletes launchd plists of idle Apache instances
#

require 'fileutils'
require 'cfpropertylist'
require 'logger'
require 'socket'
require 'securerandom'
require 'net-telnet'
require 'open3'
require 'cgi'
require 'uri'
include Socket::Constants
class SharePointNode
    attr_accessor :name
    attr_accessor :path
    def initialize(name, path)
        @path = path
        @name = URI::unescape(name)
    end
end
$LaunchAgentsDir = "/Library/LaunchAgents"
$LaunchJobHandle = "org.apache.httpd.webdavfilesharing"
$ConfigDir = "/etc/wfs"
$SharingConfigFilePath = "#{$ConfigDir}/httpd_webdavsharing_sharepoints.conf"
$killerIntervalSeconds = 120
$SharedSecretFilePath = "/Library/Server/Wiki/Config/shared/shared_secret"
$ServerWebConfigFilePath = "/Library/Server/Web/Config/apache2/WebConfigProperties.plist"
$ServerSetupDonePath = "/var/db/.ServerSetupDone"

class Service
    def plistPathForLabel(label)
        return "#{$LaunchAgentsDir}/#{label}.plist"
    end
    def labelForPlistPath(plistPath)
        return File.basename(plistPath, ".plist")
    end
    def createService(plist)
        plistPath = plistPathForLabel(plist['Label'])
        plistObject = CFPropertyList::List.new
        plistObject.value = CFPropertyList.guess(plist)
        plistObject.save(plistPath, CFPropertyList::List::FORMAT_XML)
        FileUtils.chown_R(@userName, "staff", plistPath)
        FileUtils.chmod_R(0700, plistPath)
        $logger.debug("createService, plist=#{plist}")
    end
    def getServiceEnabled(label)
        system("/bin/launchctl", "list", label, :out=>'/dev/null', :err=>'/dev/null')
        return $?.exitstatus == 0
    end
    def setServiceEnabled(label, running)
        action = running ? "load" : "unload"
        $logger.info("#{action} #{label}")
        system("/bin/launchctl", action, "-w", plistPathForLabel(label), :out=>'/dev/null', :err=>'/dev/null')
    end
    def destroyService(label)
        $logger.info("destroyService, label=#{label}")
        FileUtils.rm_rf(plistPathForLabel(label))
    end
end
class SharePointManager
    attr_reader :allShares
    def initialize
        @db = "/Local/Default"
        @allShares = []
        @homeDirSharePointConfg = <<-EOT
        # Dynamically generated by #{$0} at #{Time.now}
        # For home directories
        <Directory \"${UserHomeDir}\">
        Require ip 127.0.0.1 ::1
        DAV On
        AllowOverride None
        </Directory>
        RewriteRule ^/${UserUUID}/${UserName}(.*)$ \"${UserHomeDir}$1\" [NS]
        RequestHeader edit Destination "^https://[^/]*/(webdav/)*${UserName}(.*)$" "http://localhost:${UserPort}${UserHomeDir}$2\"
        Substitute \"s|${UserUUID}${UserHomeDir}|webdav/${UserName}|n\"
        Substitute \"s|${UserHomeDir}|/webdav/${UserName}|n\"
        EOT
    end
    def updateSharePoints
        @allShares = []
        sharePointsPlistString, ignoredStatus = Open3.capture2("/usr/bin/dscl","-plist", ".",  "-readall", "SharePoints", "webdav_shared", "dsAttrTypeNative:webdav_name", "dsAttrTypeNative:directory_path")
        sharePointsPlist = CFPropertyList::List.new(:data => sharePointsPlistString)
        allSharePoints = CFPropertyList.native_types(sharePointsPlist.value)
        allSharePoints.each do |sharePoint|
            if sharePoint["dsAttrTypeNative:webdav_shared"].nil? || sharePoint["dsAttrTypeNative:webdav_shared"][0] != "1" || sharePoint["dsAttrTypeNative:directory_path"].nil?
                next
            end
            if sharePoint["dsAttrTypeNative:webdav_name"].nil?
                sharePointName = sharePoint["dsAttrTypeStandard:RecordName"][0]
            else
                sharePointName = sharePoint["dsAttrTypeNative:webdav_name"][0]
            end
            @allShares << SharePointNode.new(sharePointName, sharePoint["dsAttrTypeNative:directory_path"][0])
        end
    end
    def regenerateSharePointConfig
        sharePointConfigStr = @homeDirSharePointConfg
        @allShares.each do |share|
            if "/" + share.name == share.path
                $logger.info("Creating simple config for share point #{share.name}")
                sharePointConfigStr += <<-EOT
                
                # For simple share point named \"#{share.name}\" at path \"#{share.path}\"
                <Directory \"#{share.path}\">
                Require ip 127.0.0.1 ::1
                DAV On
                AllowOverride None
                </Directory>
                RequestHeader edit Destination "^.*?/#{share.name}(.*)$" "http://localhost:${UserPort}#{share.path}$1"
                
                EOT
            else
                $logger.info("Creating substitute config for share point #{share.name}")
                sharePointConfigStr += <<-EOT
                
                # For share point named \"#{share.name}\" at path \"#{share.path}\"
                <Directory \"#{share.path}\">
                Require ip 127.0.0.1 ::1
                DAV On
                AllowOverride None
                </Directory>
                Substitute "s|${UserUUID}#{share.path}|webdav/#{share.name}|n"
                Substitute "s|#{share.path}|/webdav/#{share.name}|n"
                RewriteRule "^/${UserUUID}/#{share.name}(.*)$" "#{share.path}$1" [NS]
                RequestHeader edit Destination "^.*?/#{URI.escape(share.name)}(.*)$" "http://localhost:${UserPort}#{share.path}$1"
                
                EOT
            end
        end
        config = File.new($SharingConfigFilePath, "w")
        config.puts(sharePointConfigStr)
        config.flush
        $logger.info("Regenerated httpd_webdavsharing_sharepoints.conf")
    end
    def createSandboxFileWriteFile
        sbFileWriteFilePath = "#{$ConfigDir}/wfs_file-write.sb"
        $logger.info("Creating #{sbFileWriteFilePath}")
        
        sandboxWriteFileString = '(allow file-write* (subpath (param "userHomeDir")) (subpath (param "userLogDir"))'
        @allShares.each do |share|
            sandboxWriteFileString = sandboxWriteFileString + ' (subpath "' + share.path + '")'
        end
        sandboxWriteFileString += ')'
        if FileTest.exist?($ServerSetupDonePath)
            sandboxWriteFileString += "\n"
            sandboxWriteFileString += '(allow process-exec (subpath "/Applications/Server.app/Contents/ServerRoot/usr/sbin"))'
        end
        sandboxWriteFile = File.new(sbFileWriteFilePath, "w+", 0644)
        sandboxWriteFile.puts(sandboxWriteFileString)
        sandboxWriteFile.flush
    end
end
class UserInstance 
    attr_accessor :userPort
    attr_accessor :userUUID
    attr_accessor :userName
    attr_accessor :lastAccess
    attr_accessor :isLoaded
    def initialize(userName)
        @userName = userName
        $logger.info("Processing user #{@userName}")
        @userPort = nil
        @userUUID = nil
        @lastAccess = 0
        @isLoaded = false
        @userHomeDir = homeDirPath
        @userLogDir = logDirPath
        createHomeDir if $config["CreateHomeDirsForLocalUsers"] && !@userHomeDir.nil? && !FileTest.exists?(@userHomeDir) && File.dirname(@userHomeDir) == "/Users"
    end
    def homeDirPath
        begin
        dir = Etc.getpwnam(@userName)["dir"]    # path ends in "99" if user exists with no NFSHomeDirectory property
        rescue
            $logger.error("Invalid user #{@userName}")
            dir = nil
        end
        if dir.nil? || File.basename(dir) == "99"
            return "/dev/null"
        else
            localPath = dir.sub(/^\/Network\/Servers\/[^\/]+\//,'/')
            return dir if localPath == dir
            if FileTest.symlink?(dir.sub(localPath,'')) && FileTest.directory?(localPath)
                return localPath
            else
                return dir
            end
        end
    end
    def logDirPath
        path = "#{$config['PathForUserLogDirs']}/#{@userName}-#{$$}/Logs"
        if !FileTest.exists?(path)
            begin
                FileUtils.mkdir_p(path)
                FileUtils.chown_R(@userName, "staff", path)
                FileUtils.chmod_R(0700, path)
            rescue
                $logger.error("Exception creating log dir for user #{@userName}")
                FileUtils.rm_rf(path)
            end
        end
        return path
    end
    def createHomeDir
        msg, ignoredStatus = Open3.capture2e("/usr/sbin/createhomedir", "-b","-u", @userName)
        if FileTest.exists?(@userHomeDir)
            $logger.warn("Created home dir for user #{@userName} at #{@userHomeDir}")
        else
            $logger.error("Failed to create home dir for user #{@userName} at #{@userHomeDir}: #{msg}")
        end
    end
    def waitForResponse(port)
        timeToStopWaiting = Time.now + 10       # seconds
        while true do
            begin
                if Time.now > timeToStopWaiting
                    $logger.error("Timed out waiting for localhost:#{port} to start responding")
                    return
                end
                connection = Net::Telnet::new("Host" => "localhost", "Port" => port, "Telnetmode" => false)
                connection.close
                $logger.debug("Got a response from port #{port}, agent is ready")
                return
            rescue => e
            $logger.debug("Waiting for port #{port}... message=#{e.message}")
                sleep(0.1)
            end
        end
    end
    def createAndLoadLaunchdPlist
        userName = @userName    # for binding
        userPort = @userPort
        userUUID = @userUUID
        userHomeDir = @userHomeDir
        if $config["ShareWikiFiles"] && $config["WikiEnabled"]
            secret = Base64.encode64(OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha256'), $wikiSecret, userName)).strip
            $logger.debug("Configured to share Wiki files")
            else
            secret = ""
        end
        userDocRoot = "/"
        userLogDir = @userLogDir
        shareWikiFiles = $config["ShareWikiFiles"] ? "true" : "false"
        wikiEnabled = $config["WikiEnabled"] ? "true" : "false"
        $logger.debug("ShareWikiFiles=#{shareWikiFiles} WikiEnabled=#{wikiEnabled}")
        wikisVirtualSharePointName = $config["WikisVirtualSharePointName"]
        shareUserHomeDir = $config["SynthesizeSharePointForUserHomeDir"] && $config["ShareSharePoints"] ? "true" : "false"
        indexOption = "-Indexes"
        @plistLabel = "#{$LaunchJobHandle}.#{@userName}-#{$$}.#{@userPort}"
        if !$service.getServiceEnabled(@plistLabel)
            $logger.info("Creating plist for #{@plistLabel}")
            if $config["ApplyUserInstanceSandbox"]
                args = ["/usr/bin/sandbox-exec", "-f", "/usr/share/sandbox/wfs.sb",
                "-D", "userHomeDir=" + userHomeDir,
                "-D", "userLogDir=" + userLogDir,
                "-D", "userHostPort=" + "localhost:#{userPort}",
                "/usr/sbin/httpd", "-f", "#{$ConfigDir}/httpd_webdavsharing_template.conf", "-D", "FOREGROUND", "-k", "start"]
            else
                args = ["/usr/sbin/httpd", "-f", "#{$ConfigDir}/httpd_webdavsharing_template.conf", "-D", "FOREGROUND", "-k", "start"]
            end
            # Pass Environment variables to the CGI webdavsharing_virtual_root.rb
            # The CGI's Access to the EnvironmentVariables set here is controlled by the PassEnv directive in the httpd_webdavsharing_template.conf 
            plist = {
                "Disabled" => true, 
                "KeepAlive" => false, 
                "RunAtLoad" => true, 
                "Label" => @plistLabel,
                "EnvironmentVariables"=>{
                    "UserUUID" => userUUID, 
                    "UserPort" => userPort.to_s, 
                    "IndexOption" => indexOption, 
                    "UserName" => userName,
                    "UserHomeDir" => userHomeDir, 
                    "UserDocRoot" => userDocRoot,
                    "Secret" => secret,
                    "ShareWikiFiles" => shareWikiFiles,
                    "WikiEnabled" => wikiEnabled,
                    "WikisVirtualSharePointName" => wikisVirtualSharePointName,
                    "ShareUserHomeDir" => shareUserHomeDir,
                    "UserLogDir" => userLogDir}, 
                "GroupName" => "staff", 
                "UserName" => userName,
                "ProgramArguments" => args}
            status = $service.createService(plist)
            $logger.debug("creating #{@plistLabel} status=#{status}")
            $service.setServiceEnabled(@plistLabel, true);
        else
            $logger.debug("job already loaded for #{@plistLabel}")
        end
        @isLoaded = true
        waitForResponse(@userPort)
    end
    def unloadAndDelete
        $logger.info("disabling and destroying #{@plistLabel}")
        $service.setServiceEnabled(@plistLabel, false);
        destroyService(@plistLabel)
        @isLoaded = false
    end
end
class Mapper
    attr_accessor :userDict
    def initialize
        $wikiSecret = ""
        $service = Service.new
        $logger.info("Starting mapper")
        cleanUp
        @userDict = {}
    end
    def cleanUp
        Dir.glob("{$LaunchAgentsDir}/#{$LaunchJobHandle}.*") do |path|
            system("/bin/launchctl", "unload", "-w", labelForPlistPath(path), :out=>'/dev/null', :err=>'/dev/null')
            FileUtils.rm_rf(path)
        end
        if $config["RemoveUserLogDirsAtStartup"] && $config["PathForUserLogDirs"].match(/^\/private\/var\/run\/.+/)
            $logger.info("Cleaning up previous UserLogDirs at #{$config['PathForUserLogDirs']}")
            FileUtils.rm_rf($config["PathForUserLogDirs"])
        end
    end
    def label(userName)
        return "{$LaunchJobHandle}.#{userName}-#{$$}.#{portForUserName(userName)}"
    end
    def apacheInstanceIsRunningForUserName?(userName)
        return $service.getServiceEnabled(label(userName))
    end
    def portForUserName(userName)
        if @userDict[userName].nil?
            @userDict[userName] = UserInstance.new(userName)
        end
        port = @userDict[userName].userPort
        @userDict[userName].lastAccess = Time.now
        if port.nil?
            socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
            sockaddr = Socket.pack_sockaddr_in( 0, '127.0.0.1' )
            socket.bind( sockaddr )
            port = Socket.unpack_sockaddr_in(socket.getsockname)[0]
            socket.close
            @userDict[userName].userPort = port
            $logger.debug("System assigned port #{port} to user: #{userName}")
        end
        return port
    end
    def uuidForUserName(userName)
        # Keeping the dictionary here means it will be destroyed when Apache is restarted,
        # which means all the per-user Apache instances become invalid, so they need to be killed
        # or just allowed to time out and die
        if @userDict[userName].nil?
            @userDict[userName] = UserInstance.new(userName)
        end
        uuid = @userDict[userName].userUUID
        if uuid.nil?
            uuid = SecureRandom.uuid
            @userDict[userName].userUUID = uuid
        end
        return uuid
    end
    def urlForUserName(userName)
        port = portForUserName(userName)
        uuid = uuidForUserName(userName)
        if port.nil? || uuid.nil?
            return "NULL"
        else
            insureApacheInstanceIsRunningForUserName(userName)
            return "http://localhost:#{port}/#{uuid}"
        end
    end
    def insureApacheInstanceIsRunningForUserName(userName)
        if $wikiSecret.empty? && $config["ShareWikiFiles"] && $config["WikiEnabled"]
            timeToStopWaiting = Time.now + 10    # seconds
            while !FileTest.exists?($SharedSecretFilePath) && Time.now < timeToStopWaiting do
                $logger.warn("Waiting for #{$SharedSecretFilePath}")
                sleep 2
            end
            if !FileTest.exists?($SharedSecretFilePath)
                $logger.error("Wiki file sharing not available for user #{userName} because #{$SharedSecretFilePath} does not exist")
                $wikiSecret = ""
            else
                sf = File.open($SharedSecretFilePath, 'r')
                $wikiSecret = sf.read
                sf.close
            end
        end
        return if apacheInstanceIsRunningForUserName?(userName)
        @userDict[userName].createAndLoadLaunchdPlist
    end
    def killExpired
        @userDict.each do |userName, instance|
            if instance.isLoaded && Time.now.to_i - instance.lastAccess.to_i > $config["InactivityTimeoutSeconds"]
                $logger.info("Process for user #{instance.userName} has exceeded idle threshold")
                instance.unloadAndDelete
                @userDict[userName].userPort = nil
            end
        end
    end
end
class Configger
    attr_accessor :properties
    def initialize(configFilePath)
        begin
            plist = CFPropertyList::List.new(:file => configFilePath)
            configFileSettings = CFPropertyList.native_types(plist.value)
            if configFileSettings.nil?
                configSettings = {"ConfigFileUnusable" => true}
            else
                configSettings = configFileSettings
            end
            
        rescue
            configSettings = {"ConfigFileUnusable" => true}
        end
        @properties = defaultConfig.merge(configSettings)
        # Give settings from Server config precedence if Server is promoted
        addServerWebConfigSettings if FileTest.exist?($ServerSetupDonePath)
    end
    def addServerWebConfigSettings
        if FileTest.exists?($ServerWebConfigFilePath)
            plist = CFPropertyList::List.new(:file => $ServerWebConfigFilePath)
            configFileSettings = CFPropertyList.native_types(plist.value)
            if !configFileSettings.nil?
                serverWebDAVSharingSettings = configFileSettings["WebDAVSharing"]
                @properties = @properties.merge(serverWebDAVSharingSettings)
            end
        end
    end
    def defaultConfig
        return { "InactivityTimeoutSeconds" => 3600,
            "CreateHomeDirsForLocalUsers" => true,
            "PathForUserLogDirs" => "/private/var/run/webdav_sharing",
            "RemoveUserLogDirsAtStartup" => true,
            "AllowLongUserName" => false,
            "ShareWikiFiles" => false,
            "WikiEnabled" => false,
            "ShareSharePoints" => true,
            "SynthesizeSharePointForUserHomeDir" => true,
            "WikisVirtualSharePointName" => "Wikis",
            "LogFilePath" => "/Library/Logs/WebDAVFileSharing.log",
            "LogLevel" => "info"
        }
    end
end

raise "Insufficient privileges" if Process.euid != 0
$config = Configger.new("#{$ConfigDir}/wfs.plist").properties
$logger = Logger.new($config["LogFilePath"])
FileUtils.chmod(0700, $config["LogFilePath"])
case $config["LogLevel"].downcase
    when "debug"
    $logger.level = Logger::DEBUG
    when "info"
    $logger.level = Logger::INFO
    when "warn", "warning"
    $logger.level = Logger::WARN
    when "error"
    $logger.level = Logger::ERROR
    else
    logger.level = Logger::INFO
end
$stdin.sync = true
$stdout.sync = true
$logger.warn("Unable to read settings from config file; using defaults") if $config["ConfigFileUnusable"]
sharePointManager = SharePointManager.new
sharePointManager.updateSharePoints
sharePointManager.regenerateSharePointConfig
sharePointManager.createSandboxFileWriteFile if $config["ApplyUserInstanceSandbox"]
sleep(1)
mapper = Mapper.new
Signal.trap("TERM") do
    $logger.info("Caught SIGTERM")
    #mapper.cleanUp
    #Can't clean up while handling SIGTERM
    exit
end

killer = Thread.new {
while true do
    sleep($killerIntervalSeconds)
    mapper.killExpired
    Thread.pass
end
}

listener = Thread.new {
while true do
    maxUserNameLength = 255
    authName = $stdin.gets
    next if authName.nil? || authName.length == 0
    authName = authName.slice(0..maxUserNameLength-1).chomp
    begin
        userName = Etc.getpwnam(authName)["name"]
    rescue
        $logger.error("Unable to obtain real username for authenticated user #{authName}")
        $stdout.puts("NULL")
        next
    end
    $logger.debug("read: authName=#{authName}, userName=#{userName}")
    if authName != userName
        if $config["AllowLongUserName"]
            $logger.info("Authenticated as #{authName}, proceeding with short name #{userName}")
            $stdout.puts(mapper.urlForUserName(userName))
        else
            $logger.error("Authenticated as #{authName}, but denying access because short name #{userName} is required")
            $stdout.puts("NULL")
        end
    else
        $stdout.puts(mapper.urlForUserName(userName))
    end
end
}

#killer.join
listener.join
